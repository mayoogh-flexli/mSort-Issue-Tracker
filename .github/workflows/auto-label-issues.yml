name: Auto-label Issues

on:
  issues:
    types: [opened, edited]

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Auto-label using GitHub Script
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';

            // -------------------------------
            // COMPONENT â†’ LABEL MAPPING
            // -------------------------------
            const componentLabelMap = {
              'drive motor, motherboard': 'F1_bot_movement',
              'station reader': 'F2_station_reader',
              'diverter': 'F3_switching',
              'wtm-issue': 'F4_collision',
              'infeed-issue': 'F5_infeed',
              'afc, electromagnet': 'F6_drop_off',
              'motherboard closure': 'F7_motherboard_closure'
            };

            // Extract "Affected Component"
            const compMatch = body.match(/###\s*Affected Component\s*\n\s*(.+)/i);
            if (compMatch) {
              const compRaw = compMatch[1].trim().toLowerCase();

              for (const key in componentLabelMap) {
                if (compRaw.includes(key)) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [componentLabelMap[key]]
                  });
                }
              }
            }

            // -------------------------------
            // TITLE BASED LABELING
            // -------------------------------
            const titleLabelMap = [
              { keyword: '[wtm]', label: 'F4_collision' },
              { keyword: '[infeed]', label: 'F5_infeed' }
              // Add more here if needed
            ];

            for (const rule of titleLabelMap) {
              if (title.toLowerCase().includes(rule.keyword.toLowerCase())) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: [rule.label]
                });
              }
            }

            // -------------------------------
            // YOUR EXISTING REGEX LABEL LOGIC
            // -------------------------------
            
            // Parse component
            const componentMatch = body.match(/###\s*Affected Component\s*\n\s*(.+)/i);
            if (componentMatch) {
              const component = componentMatch[1].trim().toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/\//g, '-')
                .replace(/[()]/g, '');
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [`component:${component}`]
              });
            }

            // Parse issue category
            const categoryMatch = body.match(/###\s*Issue Category\s*\n\s*(.+)/i);
            if (categoryMatch) {
              const category = categoryMatch[1].trim().toLowerCase();
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [`category:${category}`]
              });
            }

            // Parse clarity
            const clarityMatch = body.match(/###\s*Clarity of the Issue\s*\n\s*(.+)/i);
            if (clarityMatch) {
              const clarity = clarityMatch[1].trim().toLowerCase();
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [`clarity:${clarity}`]
              });
            }

            // Parse priority
            const priorityMatch = body.match(/###\s*Priority\s*\n\s*(P[0-3])/i);
            if (priorityMatch) {
              const priority = priorityMatch[1].toLowerCase();
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [priority]
              });
            }

            // Parse bot operational status
            const botStatusMatch = body.match(/###\s*Bot Operational Status\s*\n\s*(.+)/i);
            if (botStatusMatch) {
              const status = botStatusMatch[1].trim().toLowerCase();
              if (status.includes('down')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['bot-down']
                });
              } else if (status.includes('degraded')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['bot-degraded']
                });
              }
            }

            console.log("Auto labeling completed with component + title rules.");
